var N = null;var searchIndex = {};
searchIndex["finchers_tungstenite"]={"doc":"WebSocket support for Finchers based on tungstenite.","items":[[3,"HandshakeError","finchers_tungstenite","The error type during handling WebSocket handshake.",N,N],[3,"Ws","","A type representing the result of handshake handling.",N,N],[3,"WsEndpoint","","An instance of `Endpoint` which handles the WebSocket handshake request.",N,N],[4,"HandshakeErrorKind","","",N,N],[13,"MissingHeader","","",0,N],[12,"name","finchers_tungstenite::HandshakeErrorKind","",0,N],[13,"InvalidHeader","finchers_tungstenite","",0,N],[12,"name","finchers_tungstenite::HandshakeErrorKind","",0,N],[13,"InvalidSecWebSocketKey","finchers_tungstenite","",0,N],[13,"InvalidSecWebSocketVersion","","",0,N],[5,"ws","","Create an endpoint which handles the WebSocket handshake request.",N,[[],["wsendpoint"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"from","","",1,[[["handshakeerrorkind"]],["self"]]],[11,"status_code","","",1,[[["self"]],["statuscode"]]],[11,"kind","","",1,[[["self"]],["handshakeerrorkind"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["wsendpoint"]]],[11,"apply","","",2,[[["self"],["applycontext"]],["applyresult"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"config","","Sets the configuration for upgraded WebSocket connection.",3,[[["self"],["websocketconfig"]],["ws"]]],[11,"on_upgrade","","Creates an `Output` with the specified function which constructs a `Future` representing the task after upgrading the protocol to WebSocket.",3,[[["self"],["f"]],[""]]],[6,"WsTransport","","",N,N]],"paths":[[4,"HandshakeErrorKind"],[3,"HandshakeError"],[3,"WsEndpoint"],[3,"Ws"]]};
searchIndex["tokio_tungstenite"]={"doc":"Async WebSocket usage.","items":[[3,"WebSocketStream","tokio_tungstenite","A wrapper around an underlying raw stream which implements the WebSocket protocol.",N,N],[3,"ConnectAsync","","Future returned from client_async() which will resolve once the connection handshake has finished.",N,N],[3,"AcceptAsync","","Future returned from accept_async() which will resolve once the connection handshake has finished.",N,N],[5,"connect_async","","Connect to a given URL.",N,[[["r"]],["box",["future"]]]],[5,"client_async_tls","","Creates a WebSocket handshake from a request and a stream, upgrading the stream to TLS if required.",N,[[["r"],["s"]],["box",["future"]]]],[5,"client_async","","Creates a WebSocket handshake from a request and a stream. For convenience, the user may call this with a url string, a URL, or a `Request`. Calling with `Request` allows the user to add a WebSocket protocol or other custom headers.",N,[[["r"],["s"]],["connectasync"]]],[5,"client_async_with_config","","The same as `client_async()` but the one can specify a websocket configuration. Please refer to `client_async()` for more details.",N,[[["r"],["s"],["option",["websocketconfig"]]],["connectasync"]]],[5,"accept_async","","Accepts a new WebSocket connection with the provided stream.",N,[[["s"]],["acceptasync",["nocallback"]]]],[5,"accept_async_with_config","","The same as `accept_async()` but the one can specify a websocket configuration. Please refer to `accept_async()` for more details.",N,[[["s"],["option",["websocketconfig"]]],["acceptasync",["nocallback"]]]],[5,"accept_hdr_async","","Accepts a new WebSocket connection with the provided stream.",N,[[["s"],["c"]],["acceptasync"]]],[5,"accept_hdr_async_with_config","","The same as `accept_hdr_async()` but the one can specify a websocket configuration. Please refer to `accept_hdr_async()` for more details.",N,[[["s"],["c"],["option",["websocketconfig"]]],["acceptasync"]]],[0,"stream","","Convenience wrapper for streams to switch between plain TCP and TLS at runtime.",N,N],[4,"Stream","tokio_tungstenite::stream","Stream, either plain TCP or TLS.",N,N],[13,"Plain","","Unencrypted socket stream.",0,N],[13,"Tls","","Encrypted socket stream.",0,N],[8,"NoDelay","","Trait to switch TCP_NODELAY.",N,N],[10,"set_nodelay","","Set the TCP_NODELAY option to the given value.",1,[[["self"],["bool"]],["ioresult"]]],[11,"read","","",0,N],[11,"write","","",0,N],[11,"flush","","",0,[[["self"]],["ioresult"]]],[11,"set_nodelay","","",0,[[["self"],["bool"]],["ioresult"]]],[11,"prepare_uninitialized_buffer","","",0,N],[11,"read_buf","","",0,[[["self"],["b"]],["poll",["usize","ioerror"]]]],[11,"shutdown","","",0,[[["self"]],["poll",["ioerror"]]]],[11,"write_buf","","",0,[[["self"],["b"]],["poll",["usize","ioerror"]]]],[6,"MaybeTlsStream","tokio_tungstenite","A stream that might be protected with TLS.",N,N],[11,"from_raw_socket","","Convert a raw socket into a WebSocketStream without performing a handshake.",2,[[["s"],["role"],["option",["websocketconfig"]]],["self"]]],[11,"from_partially_read","","Convert a raw socket into a WebSocketStream without performing a handshake.",2,[[["s"],["vec",["u8"]],["role"],["option",["websocketconfig"]]],["self"]]],[11,"poll","","",2,[[["self"]],["poll",["option","wserror"]]]],[11,"start_send","","",2,[[["self"],["message"]],["startsend",["message","wserror"]]]],[11,"poll_complete","","",2,[[["self"]],["poll",["wserror"]]]],[11,"close","","",2,[[["self"]],["poll",["wserror"]]]],[11,"poll","","",3,[[["self"]],["poll",["wserror"]]]],[11,"poll","","",4,[[["self"]],["poll",["wserror"]]]]],"paths":[[4,"Stream"],[8,"NoDelay"],[3,"WebSocketStream"],[3,"ConnectAsync"],[3,"AcceptAsync"]]};
searchIndex["tungstenite"]={"doc":"Lightweight, flexible WebSockets for Rust.","items":[[4,"Message","tungstenite","An enum representing the various forms of a WebSocket message.",N,N],[13,"Text","","A text WebSocket message",0,N],[13,"Binary","","A binary WebSocket message",0,N],[13,"Ping","","A ping message with the specified payload",0,N],[13,"Pong","","A pong message with the specified payload",0,N],[0,"error","","Error handling.",N,N],[4,"Error","tungstenite::error","Possible WebSocket errors",N,N],[13,"ConnectionClosed","","WebSocket connection closed (normally)",1,N],[13,"Io","","Input-output error",1,N],[13,"Tls","","TLS error",1,N],[13,"Capacity","","Buffer capacity exhausted",1,N],[13,"Protocol","","Protocol violation",1,N],[13,"SendQueueFull","","Message send queue full",1,N],[13,"Utf8","","UTF coding error",1,N],[13,"Url","","Invlid URL.",1,N],[13,"Http","","HTTP error.",1,N],[0,"tls","","TLS error wrapper module, feature-gated.",N,N],[3,"Error","tungstenite::error::tls","An error returned from the TLS implementation.",N,N],[6,"Result","tungstenite::error","Result type of all Tungstenite library calls.",N,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"description","","",1,[[["self"]],["str"]]],[11,"from","","",1,[[["error"]],["self"]]],[11,"from","","",1,[[["utf8error"]],["self"]]],[11,"from","","",1,[[["fromutf8error"]],["self"]]],[11,"from","","",1,[[["error"]],["self"]]],[11,"from","","",1,[[["error"]],["self"]]],[0,"protocol","tungstenite","Generic WebSocket message stream.",N,N],[3,"CloseFrame","tungstenite::protocol","A struct representing the close command.",N,N],[12,"code","","The reason as a code.",2,N],[12,"reason","","The reason as text string.",2,N],[3,"WebSocketConfig","","The configuration for WebSocket connection.",N,N],[12,"max_send_queue","","The size of the send queue. You can use it to turn on/off the backpressure features. `None` means here that the size of the queue is unlimited. The default value is the unlimited queue.",3,N],[12,"max_message_size","","The maximum size of a message. `None` means no size limit. The default value is 64 megabytes which should be reasonably big for all normal use-cases but small enough to prevent memory eating by a malicious user.",3,N],[12,"max_frame_size","","The maximum size of a single message frame. `None` means no size limit. The limit is for frame payload NOT including the frame header. The default value is 16 megabytes which should be reasonably big for all normal use-cases but small enough to prevent memory eating by a malicious user.",3,N],[3,"WebSocket","","WebSocket input-output stream.",N,N],[4,"Message","","An enum representing the various forms of a WebSocket message.",N,N],[13,"Text","","A text WebSocket message",0,N],[13,"Binary","","A binary WebSocket message",0,N],[13,"Ping","","A ping message with the specified payload",0,N],[13,"Pong","","A pong message with the specified payload",0,N],[4,"Role","","Indicates a Client or Server role of the websocket",N,N],[13,"Server","","This socket is a server",4,N],[13,"Client","","This socket is a client",4,N],[0,"frame","","Utilities to work with raw WebSocket frames.",N,N],[3,"Frame","tungstenite::protocol::frame","A struct representing a WebSocket frame.",N,N],[3,"FrameHeader","","A struct representing a WebSocket frame header.",N,N],[12,"is_final","","Indicates that the frame is the last one of a possibly fragmented message.",5,N],[12,"rsv1","","Reserved for protocol extensions.",5,N],[12,"rsv2","","Reserved for protocol extensions.",5,N],[12,"rsv3","","Reserved for protocol extensions.",5,N],[12,"opcode","","WebSocket protocol opcode.",5,N],[3,"CloseFrame","","A struct representing the close command.",N,N],[12,"code","","The reason as a code.",2,N],[12,"reason","","The reason as text string.",2,N],[3,"FrameSocket","","A reader and writer for WebSocket frames.",N,N],[0,"coding","","Various codes defined in RFC 6455.",N,N],[4,"OpCode","tungstenite::protocol::frame::coding","WebSocket message opcode as in RFC 6455.",N,N],[13,"Data","","Data (text or binary).",6,N],[13,"Control","","Control message (close, ping, pong).",6,N],[4,"Data","","Data opcodes as in RFC 6455",N,N],[13,"Continue","","0x0 denotes a continuation frame",7,N],[13,"Text","","0x1 denotes a text frame",7,N],[13,"Binary","","0x2 denotes a binary frame",7,N],[13,"Reserved","","0x3-7 are reserved for further non-control frames",7,N],[4,"Control","","Control opcodes as in RFC 6455",N,N],[13,"Close","","0x8 denotes a connection close",8,N],[13,"Ping","","0x9 denotes a ping",8,N],[13,"Pong","","0xa denotes a pong",8,N],[13,"Reserved","","0xb-f are reserved for further control frames",8,N],[4,"CloseCode","","Status code used to indicate why an endpoint is closing the WebSocket connection.",N,N],[13,"Normal","","Indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.",9,N],[13,"Away","","Indicates that an endpoint is \"going away\", such as a server going down or a browser having navigated away from a page.",9,N],[13,"Protocol","","Indicates that an endpoint is terminating the connection due to a protocol error.",9,N],[13,"Unsupported","","Indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).",9,N],[13,"Status","","Indicates that no status code was included in a closing frame. This close code makes it possible to use a single method, `on_close` to handle even cases where no close code was provided.",9,N],[13,"Abnormal","","Indicates an abnormal closure. If the abnormal closure was due to an error, this close code will not be used. Instead, the `on_error` method of the handler will be called with the error. However, if the connection is simply dropped, without an error, this close code will be sent to the handler.",9,N],[13,"Invalid","","Indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message).",9,N],[13,"Policy","","Indicates that an endpoint is terminating the connection because it has received a message that violates its policy.  This is a generic status code that can be returned when there is no other more suitable status code (e.g., Unsupported or Size) or if there is a need to hide specific details about the policy.",9,N],[13,"Size","","Indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.",9,N],[13,"Extension","","Indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake.  The list of extensions that are needed should be given as the reason for closing. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.",9,N],[13,"Error","","Indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.",9,N],[13,"Restart","","Indicates that the server is restarting. A client may choose to reconnect, and if it does, it should use a randomized delay of 5-30 seconds between attempts.",9,N],[13,"Again","","Indicates that the server is overloaded and the client should either connect to a different IP (when multiple targets exist), or reconnect to the same IP when a user has performed an action.",9,N],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"eq","","",6,[[["self"],["opcode"]],["bool"]]],[11,"ne","","",6,[[["self"],["opcode"]],["bool"]]],[11,"clone","","",6,[[["self"]],["opcode"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"eq","","",7,[[["self"],["data"]],["bool"]]],[11,"ne","","",7,[[["self"],["data"]],["bool"]]],[11,"clone","","",7,[[["self"]],["data"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"eq","","",8,[[["self"],["control"]],["bool"]]],[11,"ne","","",8,[[["self"],["control"]],["bool"]]],[11,"clone","","",8,[[["self"]],["control"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"into","","",6,[[["self"]],["u8"]]],[11,"from","","",6,[[["u8"]],["opcode"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"eq","","",9,[[["self"],["closecode"]],["bool"]]],[11,"ne","","",9,[[["self"],["closecode"]],["bool"]]],[11,"clone","","",9,[[["self"]],["closecode"]]],[11,"is_allowed","","Check if this CloseCode is allowed.",9,[[["self"]],["bool"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"into","","",9,[[["self"]],["u16"]]],[11,"from","","",9,[[["u16"]],["closecode"]]],[11,"fmt","tungstenite::protocol","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["closeframe"]]],[11,"into_owned","","Convert into a owned string.",2,[[["self"]],["closeframe"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","tungstenite::protocol::frame","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["frameheader"]]],[11,"default","","",5,[[],["self"]]],[11,"parse","","Parse a header from an input stream. Returns `None` if insufficient data and does not consume anything in this case. Payload size is returned along with the header.",5,[[["cursor"]],["result",["option"]]]],[11,"len","","Get the size of the header formatted with given payload length.",5,[[["self"],["u64"]],["usize"]]],[11,"format","","Format a header for given payload size.",5,N],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"clone","","",10,[[["self"]],["frame"]]],[11,"len","","Get the length of the frame. This is the length of the header + the length of the payload.",10,[[["self"]],["usize"]]],[11,"header","","Get a reference to the frame's header.",10,[[["self"]],["frameheader"]]],[11,"header_mut","","Get a mutable reference to the frame's header.",10,[[["self"]],["frameheader"]]],[11,"payload","","Get a reference to the frame's payload.",10,[[["self"]],["vec"]]],[11,"payload_mut","","Get a mutable reference to the frame's payload.",10,[[["self"]],["vec"]]],[11,"into_data","","Consume the frame into its payload as binary.",10,[[["self"]],["vec",["u8"]]]],[11,"into_string","","Consume the frame into its payload as string.",10,[[["self"]],["stdresult",["string","fromutf8error"]]]],[11,"message","","Create a new data frame.",10,[[["vec",["u8"]],["opcode"],["bool"]],["frame"]]],[11,"pong","","Create a new Pong control frame.",10,[[["vec",["u8"]]],["frame"]]],[11,"ping","","Create a new Ping control frame.",10,[[["vec",["u8"]]],["frame"]]],[11,"close","","Create a new Close control frame.",10,[[["option",["closeframe"]]],["frame"]]],[11,"from_payload","","Create a frame from given header and data.",10,[[["frameheader"],["vec",["u8"]]],["self"]]],[11,"format","","Write a frame out to a buffer",10,N],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new frame socket.",11,[[["stream"]],["self"]]],[11,"from_partially_read","","Create a new frame socket from partially read data.",11,[[["stream"],["vec",["u8"]]],["self"]]],[11,"into_inner","","Extract a stream from the socket.",11,N],[11,"get_ref","","Returns a shared reference to the inner stream.",11,[[["self"]],["stream"]]],[11,"get_mut","","Returns a mutable reference to the inner stream.",11,[[["self"]],["stream"]]],[11,"read_frame","","Read a frame from stream.",11,[[["self"],["option",["usize"]]],["result",["option"]]]],[11,"write_frame","","Write a frame to stream.",11,[[["self"],["frame"]],["result"]]],[11,"write_pending","","Complete pending write, if any.",11,[[["self"]],["result"]]],[11,"fmt","tungstenite","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["message"]],["bool"]]],[11,"ne","","",0,[[["self"],["message"]],["bool"]]],[11,"clone","","",0,[[["self"]],["message"]]],[11,"text","","Create a new text WebSocket message from a stringable.",0,[[["s"]],["message"]]],[11,"binary","","Create a new binary WebSocket message by converting to Vec.",0,[[["b"]],["message"]]],[11,"is_text","","Indicates whether a message is a text message.",0,[[["self"]],["bool"]]],[11,"is_binary","","Indicates whether a message is a binary message.",0,[[["self"]],["bool"]]],[11,"is_ping","","Indicates whether a message is a ping message.",0,[[["self"]],["bool"]]],[11,"is_pong","","Indicates whether a message is a pong message.",0,[[["self"]],["bool"]]],[11,"len","","Get the length of the WebSocket message.",0,[[["self"]],["usize"]]],[11,"is_empty","","Returns true if the WebSocket message has no content. For example, if the other side of the connection sent an empty string.",0,[[["self"]],["bool"]]],[11,"into_data","","Consume the WebSocket and return it as binary data.",0,[[["self"]],["vec",["u8"]]]],[11,"into_text","","Attempt to consume the WebSocket message and convert it to a String.",0,[[["self"]],["result",["string"]]]],[11,"to_text","","Attempt to get a &str from the WebSocket message, this will try to convert binary data to utf8.",0,[[["self"]],["result",["str"]]]],[11,"from","","",0,[[["string"]],["message"]]],[11,"from","","",0,[[["str"]],["message"]]],[11,"from","","",0,N],[11,"from","","",0,[[["vec",["u8"]]],["message"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["stdresult",["error"]]]],[11,"fmt","tungstenite::protocol","",4,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["role"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["websocketconfig"]]],[11,"default","","",3,[[],["self"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"from_raw_socket","","Convert a raw socket into a WebSocket without performing a handshake.",12,[[["stream"],["role"],["option",["websocketconfig"]]],["self"]]],[11,"from_partially_read","","Convert a raw socket into a WebSocket without performing a handshake.",12,[[["stream"],["vec",["u8"]],["role"],["option",["websocketconfig"]]],["self"]]],[11,"get_ref","","Returns a shared reference to the inner stream.",12,[[["self"]],["stream"]]],[11,"get_mut","","Returns a mutable reference to the inner stream.",12,[[["self"]],["stream"]]],[11,"set_config","","Change the configuration.",12,N],[11,"read_message","","Read a message from stream, if possible.",12,[[["self"]],["result",["message"]]]],[11,"write_message","","Send a message to stream, if possible.",12,[[["self"],["message"]],["result"]]],[11,"close","","Close the connection.",12,[[["self"],["option",["closeframe"]]],["result"]]],[11,"write_pending","","Flush the pending send queue.",12,[[["self"]],["result"]]],[0,"client","tungstenite","Methods to connect to an WebSocket as a client.",N,N],[5,"connect_with_config","tungstenite::client","Connect to the given WebSocket in blocking mode.",N,[[["req"],["option",["websocketconfig"]]],["result"]]],[5,"connect","","Connect to the given WebSocket in blocking mode.",N,[[["req"]],["result"]]],[5,"url_mode","","Get the mode of the given URL.",N,[[["url"]],["result",["mode"]]]],[5,"client_with_config","","Do the client handshake over the given stream given a web socket configuration. Passing `None` as configuration is equal to calling `client()` function.",N,[[["req"],["stream"],["option",["websocketconfig"]]],["stdresult",["handshakeerror"]]]],[5,"client","","Do the client handshake over the given stream.",N,[[["req"],["stream"]],["stdresult",["handshakeerror"]]]],[6,"AutoStream","","TCP stream switcher (plain/TLS).",N,N],[0,"server","tungstenite","Methods to accept an incoming WebSocket connection on a server.",N,N],[5,"accept_with_config","tungstenite::server","Accept the given Stream as a WebSocket.",N,[[["s"],["option",["websocketconfig"]]],["result",["websocket","handshakeerror"]]]],[5,"accept","","Accept the given Stream as a WebSocket.",N,[[["s"]],["result",["websocket","handshakeerror"]]]],[5,"accept_hdr_with_config","","Accept the given Stream as a WebSocket.",N,[[["s"],["c"],["option",["websocketconfig"]]],["result",["websocket","handshakeerror"]]]],[5,"accept_hdr","","Accept the given Stream as a WebSocket.",N,[[["s"],["c"]],["result",["websocket","handshakeerror"]]]],[0,"handshake","tungstenite","WebSocket handshake control.",N,N],[3,"MidHandshake","tungstenite::handshake","A WebSocket handshake.",N,N],[4,"HandshakeError","","A handshake result.",N,N],[13,"Interrupted","","Handshake was interrupted (would block).",13,N],[13,"Failure","","Handshake failed.",13,N],[0,"headers","","HTTP Request and response header handling.",N,N],[3,"Headers","tungstenite::handshake::headers","HTTP request or response headers.",N,N],[3,"HeadersIter","","The iterator over headers.",N,N],[17,"MAX_HEADERS","","Limit for the number of header lines.",N,N],[8,"FromHttparse","","Trait to convert raw objects into HTTP parseables.",N,N],[10,"from_httparse","","Convert raw object into parsed HTTP headers.",14,[[["t"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"find_first","","Get first header with the given name, if any.",15,[[["self"],["str"]],["option"]]],[11,"find","","Iterate over all headers with the given name.",15,[[["self"],["str"]],["headersiter"]]],[11,"header_is","","Check if the given header has the given value.",15,[[["self"],["str"],["str"]],["bool"]]],[11,"header_is_ignore_case","","Check if the given header has the given value (case-insensitive).",15,[[["self"],["str"],["str"]],["bool"]]],[11,"iter","","Allows to iterate over available headers.",15,[[["self"]],["iter"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"next","","",16,[[["self"]],["option"]]],[11,"from_httparse","","",15,N],[0,"client","tungstenite::handshake","Client handshake machine.",N,N],[3,"Request","tungstenite::handshake::client","Client request.",N,N],[12,"url","","`ws://` or `wss://` URL to connect to.",17,N],[12,"extra_headers","","Extra HTTP headers to append to the request.",17,N],[3,"ClientHandshake","","Client handshake role.",N,N],[3,"Response","","Server response.",N,N],[12,"code","","HTTP response code of the response.",18,N],[12,"headers","","Received headers.",18,N],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"add_protocol","","Adds a WebSocket protocol to the request.",17,[[["self"],["cow",["str"]]]]],[11,"add_header","","Adds a custom header to the request.",17,[[["self"],["cow",["str"]],["cow",["str"]]]]],[11,"from","","",17,[[["url"]],["self"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"start","","Initiate a client handshake.",19,[[["s"],["request"],["option",["websocketconfig"]]],["midhandshake"]]],[11,"stage_finished","","",19,[[["self"],["stageresult"]],["result",["processingresult"]]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"from_httparse","","",18,[[["response"]],["result"]]],[0,"server","tungstenite::handshake","Server handshake machine.",N,N],[3,"Request","tungstenite::handshake::server","Request from the client.",N,N],[12,"path","","Path part of the URL.",20,N],[12,"headers","","HTTP headers.",20,N],[3,"NoCallback","","Stub for callback that does nothing.",N,N],[3,"ServerHandshake","","Server handshake role.",N,N],[8,"Callback","","The callback trait.",N,N],[10,"on_request","","Called whenever the server read the request from the client and is ready to reply to it. May return additional reply headers. Returning an error resulting in rejecting the incoming connection.",21,[[["self"],["request"]],["result",["option"]]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"reply","","Reply to the response.",20,[[["self"],["option",["vec"]]],["result",["vec"]]]],[11,"from_httparse","","",20,[[["request"]],["result"]]],[11,"clone","","",22,[[["self"]],["nocallback"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"on_request","","",22,[[["self"],["request"]],["result",["option"]]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"start","","Start server handshake. `callback` specifies a custom callback which the user can pass to the handshake, this callback will be called when the a websocket client connnects to the server, you can specify the callback if you want to add additional header to the client upon join based on the incoming headers.",23,[[["s"],["c"],["option",["websocketconfig"]]],["midhandshake"]]],[11,"stage_finished","","",23,[[["self"],["stageresult"]],["result",["processingresult"]]]],[8,"HandshakeRole","tungstenite::handshake","Handshake role.",N,N],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"handshake","","Restarts the handshake process.",24,[[["self"]],["result",["handshakeerror"]]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"description","","",13,[[["self"]],["str"]]],[11,"from","","",13,[[["error"]],["self"]]],[0,"stream","tungstenite","Convenience wrapper for streams to switch between plain TCP and TLS at runtime.",N,N],[4,"Mode","tungstenite::stream","Stream mode, either plain TCP or TLS.",N,N],[13,"Plain","","Plain mode (`ws://` URL).",25,N],[13,"Tls","","TLS mode (`wss://` URL).",25,N],[4,"Stream","","Stream, either plain TCP or TLS.",N,N],[13,"Plain","","Unencrypted socket stream.",26,N],[13,"Tls","","Encrypted socket stream.",26,N],[8,"NoDelay","","Trait to switch TCP_NODELAY.",N,N],[10,"set_nodelay","","Set the TCP_NODELAY option to the given value.",27,[[["self"],["bool"]],["ioresult"]]],[11,"clone","","",25,[[["self"]],["mode"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"read","","",26,N],[11,"write","","",26,N],[11,"flush","","",26,[[["self"]],["ioresult"]]],[11,"set_nodelay","","",26,[[["self"],["bool"]],["ioresult"]]],[0,"util","tungstenite","Helper traits to ease non-blocking handling.",N,N],[8,"NonBlockingError","tungstenite::util","Non-blocking IO handling.",N,N],[10,"into_non_blocking","","Convert WouldBlock to None and don't touch other errors.",28,[[["self"]],["option"]]],[8,"NonBlockingResult","","Non-blocking IO wrapper.",N,N],[16,"Result","","Type of the converted result: `Result<Option<T>, E>`",29,N],[10,"no_block","","Perform the non-block conversion.",29,N],[11,"into_non_blocking","tungstenite::error","",1,[[["self"]],["option"]]],[11,"fmt","tungstenite::error::tls","",30,[[["self"],["formatter"]],["result",["error"]]]],[11,"description","","",30,[[["self"]],["str"]]],[11,"cause","","",30,[[["self"]],["option",["error"]]]],[11,"from","","",30,[[["error"]],["error"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result",["error"]]]]],"paths":[[4,"Message"],[4,"Error"],[3,"CloseFrame"],[3,"WebSocketConfig"],[4,"Role"],[3,"FrameHeader"],[4,"OpCode"],[4,"Data"],[4,"Control"],[4,"CloseCode"],[3,"Frame"],[3,"FrameSocket"],[3,"WebSocket"],[4,"HandshakeError"],[8,"FromHttparse"],[3,"Headers"],[3,"HeadersIter"],[3,"Request"],[3,"Response"],[3,"ClientHandshake"],[3,"Request"],[8,"Callback"],[3,"NoCallback"],[3,"ServerHandshake"],[3,"MidHandshake"],[4,"Mode"],[4,"Stream"],[8,"NoDelay"],[8,"NonBlockingError"],[8,"NonBlockingResult"],[3,"Error"]]};
initSearch(searchIndex);
